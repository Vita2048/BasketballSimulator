<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Basketball Simulator</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        .toolbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.5);
            padding: 10px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .toolbar label {
            margin-right: 5px;
        }
        .toolbar input[type="range"] {
            width: 100px;
        }
        .toolbar button {
            padding: 5px 10px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .toolbar button:hover {
            background: #0056b3;
        }
    </style>
</head>
<body>
    <canvas id="basketballCanvas"></canvas>
    <div class="toolbar">
        <label>TOP FACE: <span id="topFaceValue">1</span></label>
        <input type="range" id="topFace" min="1" max="10" value="1" oninput="updateShootParams('topFace', this.value)">
        <label>FORCE: <span id="forceValue">50%</span></label>
        <input type="range" id="force" min="0" max="100" value="50" oninput="updateShootParams('force', this.value)">
        <label>YAW: <span id="yawValue">0°</span></label>
        <input type="range" id="yaw" min="-90" max="90" value="0" oninput="updateShootParams('yaw', this.value)">
        <label>PITCH: <span id="pitchValue">0°</label>
        <input type="range" id="pitch" min="-90" max="90" value="0" oninput="updateShootParams('pitch', this.value)">
        <button onclick="shootBall()">SHOOT</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

    <script>
if (typeof THREE === 'undefined') {
    console.error("Required libraries (Three.js) not loaded!");
}
if (typeof CANNON === 'undefined') {
    console.error("Required libraries (Cannon.js) not loaded!");
} else {
    initBasketballSim();
}

function initBasketballSim() {
    const scene = new THREE.Scene();
    const canvas = document.getElementById('basketballCanvas');
    const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 15);
    camera.lookAt(0, 2, 0);

    const world = new CANNON.World();
    world.gravity.set(0, -9.82, 0);
    world.broadphase = new CANNON.NaiveBroadphase();
    world.solver.iterations = 10;

    const ballMaterial = new CANNON.Material('ballMaterial');
    const groundMaterial = new CANNON.Material('groundMaterial');
    const hoopMaterial = new CANNON.Material('hoopMaterial');
    const wallMaterial = new CANNON.Material('wallMaterial');

    world.addContactMaterial(new CANNON.ContactMaterial(ballMaterial, groundMaterial, { restitution: 0.6, friction: 0.5 }));
    world.addContactMaterial(new CANNON.ContactMaterial(ballMaterial, hoopMaterial, { restitution: 0.4, friction: 0.2 }));
    world.addContactMaterial(new CANNON.ContactMaterial(ballMaterial, wallMaterial, { restitution: 0.5, friction: 0.3 }));

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 15, 10);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 50;
    directionalLight.shadow.camera.left = -20;
    directionalLight.shadow.camera.right = 20;
    directionalLight.shadow.camera.top = 20;
    directionalLight.shadow.camera.bottom = -20;
    scene.add(directionalLight);

    const objectsToUpdate = [];

    // Load textures
    const textureLoader = new THREE.TextureLoader();
    const floorTexture = textureLoader.load('FloorTexture.jpg');
    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
    floorTexture.repeat.set(4, 4);

    const wallTexture = textureLoader.load('WallTexture.jpg');
    wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
    wallTexture.repeat.set(2, 2);

    // Floor
    const floorGeometry = new THREE.PlaneGeometry(40, 40);
    const floorMaterial = new THREE.MeshStandardMaterial({
        map: floorTexture,
        roughness: 0.3,
        metalness: 0.1,
        side: THREE.DoubleSide
    });
    const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
    floorMesh.rotation.x = -Math.PI / 2;
    floorMesh.receiveShadow = true;
    scene.add(floorMesh);

    const floorShape = new CANNON.Plane();
    const floorBody = new CANNON.Body({ mass: 0, shape: floorShape, material: groundMaterial });
    floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
    world.addBody(floorBody);

    // Wall (positioned just behind the basket)
    const hoopZPosition = 0;
    const wallZPosition = hoopZPosition - 0.6;
    const wallGeometry = new THREE.PlaneGeometry(40, 20);
    const wallMeshMaterial = new THREE.MeshStandardMaterial({
        map: wallTexture,
        side: THREE.DoubleSide
    });
    const wallMesh = new THREE.Mesh(wallGeometry, wallMeshMaterial);
    wallMesh.position.set(0, 10, wallZPosition);
    wallMesh.castShadow = true;
    wallMesh.receiveShadow = true;
    scene.add(wallMesh);

    const wallShape = new CANNON.Plane();
    const wallBody = new CANNON.Body({ mass: 0, shape: wallShape, material: wallMaterial });
    wallBody.position.set(0, 10, wallZPosition);
    wallBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
    world.addBody(wallBody);

    // Basketball Hoop
    const hoopGroup = new THREE.Group();
    const hoopHeight = 3.05;
    const backboardWidth = 1.8;
    const backboardHeight = 1.05;
    const backboardThickness = 0.05;
    const rimRadius = 0.225;
    const rimTubeRadius = 0.02;

    const backboardGeometry = new THREE.BoxGeometry(backboardWidth, backboardHeight, backboardThickness);
    const backboardMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
    const backboardMesh = new THREE.Mesh(backboardGeometry, backboardMaterial);
    backboardMesh.position.set(0, hoopHeight + backboardHeight / 2 - 0.1, -0.5);
    backboardMesh.castShadow = true;
    backboardMesh.receiveShadow = true;
    hoopGroup.add(backboardMesh);

    const backboardShape = new CANNON.Box(new CANNON.Vec3(backboardWidth / 2, backboardHeight / 2, backboardThickness / 2));
    const backboardBody = new CANNON.Body({
        mass: 0,
        shape: backboardShape,
        material: hoopMaterial,
        position: new CANNON.Vec3(backboardMesh.position.x, backboardMesh.position.y, backboardMesh.position.z)
    });
    world.addBody(backboardBody);

    const rimGeometry = new THREE.TorusGeometry(rimRadius, rimTubeRadius, 16, 32);
    const rimMaterial = new THREE.MeshStandardMaterial({ color: 0xff4500, roughness: 0.2, metalness: 0.5 });
    const rimMesh = new THREE.Mesh(rimGeometry, rimMaterial);
    rimMesh.position.set(0, hoopHeight, 0);
    rimMesh.rotation.x = Math.PI / 2;
    rimMesh.castShadow = true;
    hoopGroup.add(rimMesh);

    const rimPhysicsRadius = rimRadius + rimTubeRadius;
    const rimPhysicsHeight = rimTubeRadius * 2;
    const rimShape = new CANNON.Cylinder(rimPhysicsRadius, rimPhysicsRadius, rimPhysicsHeight, 16);
    const rimBody = new CANNON.Body({ mass: 0, material: hoopMaterial });
    const shapeOrientation = new CANNON.Quaternion();
    shapeOrientation.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
    rimBody.addShape(rimShape, new CANNON.Vec3(), shapeOrientation);
    rimBody.position.copy(rimMesh.position);
    world.addBody(rimBody);

    const netMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, side: THREE.DoubleSide });
    const netGeometry = new THREE.CylinderGeometry(rimRadius, rimRadius * 0.8, 0.4, 16, 8, true);
    const netMesh = new THREE.Mesh(netGeometry, netMaterial);
    netMesh.position.set(0, hoopHeight - 0.2, 0);
    hoopGroup.add(netMesh);

    scene.add(hoopGroup);

    const ballRadius = 0.12;
    const ballGeometry = new THREE.SphereGeometry(ballRadius, 32, 32);
    const ballMeshMaterial = new THREE.MeshStandardMaterial({
        color: 0xFF8C00,
        roughness: 0.6,
        metalness: 0.1
    });
    const ballMesh = new THREE.Mesh(ballGeometry, ballMeshMaterial);
    ballMesh.castShadow = true;
    ballMesh.receiveShadow = true;
    scene.add(ballMesh);

    const ballShape = new CANNON.Sphere(ballRadius);
    const ballBody = new CANNON.Body({
        mass: 1,
        shape: ballShape,
        material: ballMaterial,
        linearDamping: 0.1,
        angularDamping: 0.1
    });
    world.addBody(ballBody);
    objectsToUpdate.push({ mesh: ballMesh, body: ballBody });

    const initialBallPosition = new THREE.Vector3(0, ballRadius + 0.5, 10);
    
    const arrowColor = 0xff0000;
    const aimingArrow = new THREE.ArrowHelper(
        new THREE.Vector3(),
        new THREE.Vector3(),
        1,
        arrowColor,
        0.3,
        0.2
    );
    aimingArrow.line.material.transparent = true;
    aimingArrow.line.material.opacity = 0.6;
    aimingArrow.cone.material.transparent = true;
    aimingArrow.cone.material.opacity = 0.6;
    scene.add(aimingArrow);

    const shootParams = {
        topFace: 1,
        force: 50,
        yaw: 0,
        pitch: 0
    };

    function resetBall() {
        ballBody.velocity.set(0, 0, 0);
        ballBody.angularVelocity.set(0, 0, 0);
        ballBody.position.copy(initialBallPosition);
        ballMesh.position.copy(initialBallPosition);
        aimingArrow.visible = true;
    }
    resetBall();

    function updateAimingArrow() {
        const yawRad = THREE.MathUtils.degToRad(shootParams.yaw);
        const pitchRad = THREE.MathUtils.degToRad(shootParams.pitch);
        const force = shootParams.force * 0.3;

        const direction = new THREE.Vector3(
            Math.sin(yawRad) * Math.cos(pitchRad),
            Math.sin(pitchRad),
            -Math.cos(yawRad) * Math.cos(pitchRad)
        ).normalize();

        const length = Math.min(force / 5, 5);
        const originOffset = direction.clone().multiplyScalar(ballRadius * 1.1);
        const arrowOrigin = ballMesh.position.clone().add(originOffset);

        aimingArrow.position.copy(arrowOrigin);
        aimingArrow.setDirection(direction);
        aimingArrow.setLength(length, 0.3 * length, 0.2 * length);
        aimingArrow.visible = true;
    }
    updateAimingArrow();

    window.updateShootParams = function(param, value) {
        shootParams[param] = parseFloat(value);
        document.getElementById(`${param}Value`).textContent = 
            param === 'force' ? `${value}%` :
            param === 'yaw' || param === 'pitch' ? `${value}°` :
            value;
        updateAimingArrow();
    };

    window.shootBall = function() {
        if (!ballBody) return;
        aimingArrow.visible = false;

        const yawRad = THREE.MathUtils.degToRad(shootParams.yaw);
        const pitchRad = THREE.MathUtils.degToRad(shootParams.pitch);
        const force = shootParams.force * 0.3;

        const shootDirection = new THREE.Vector3(
            Math.sin(yawRad) * Math.cos(pitchRad),
            Math.sin(pitchRad),
            -Math.cos(yawRad) * Math.cos(pitchRad)
        ).normalize();

        const impulse = new CANNON.Vec3(
            shootDirection.x * force,
            shootDirection.y * force,
            shootDirection.z * force
        );

        const worldPoint = new CANNON.Vec3(
            ballBody.position.x,
            ballBody.position.y - ballRadius * 0.2,
            ballBody.position.z
        );
        ballBody.applyImpulse(impulse, worldPoint);

        setTimeout(resetBall, 3000);
    };

    const clock = new THREE.Clock();
    let oldElapsedTime = 0;

    function animate() {
        requestAnimationFrame(animate);

        const elapsedTime = clock.getElapsedTime();
        const deltaTime = elapsedTime - oldElapsedTime;
        oldElapsedTime = elapsedTime;

        world.step(1 / 60, deltaTime, 3);

        for (const obj of objectsToUpdate) {
            obj.mesh.position.copy(obj.body.position);
            obj.mesh.quaternion.copy(obj.body.quaternion);
        }

        if (aimingArrow.visible) {
            updateAimingArrow();
        }

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
}
    </script>
</body>
</html>
